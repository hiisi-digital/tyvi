/**
 * direnv integration for git guards.
 *
 * Generates .envrc files for tyvi root, lab, and optionally parent
 * directories. Provides environment variable enforcement layer.
 *
 * @module
 */

import { exists } from "@std/fs";
import { join, resolve } from "@std/path";
import type { Devspace } from "../types/mod.ts";

/**
 * Check if direnv is available on the system.
 *
 * @returns Whether direnv is installed and accessible
 */
export async function hasDirenv(): Promise<boolean> {
  try {
    const cmd = new Deno.Command("direnv", { args: ["version"], stdout: "null", stderr: "null" });
    const result = await cmd.output();
    return result.success;
  } catch {
    return false;
  }
}

/**
 * Generate .envrc content for a specific location.
 *
 * @param devspace - Devspace configuration
 * @param location - Where the .envrc will be placed
 * @returns .envrc content
 */
export function generateEnvrc(
  devspace: Devspace,
  location: "root" | "lab" | "parent",
): string {
  const rootPath = resolve(devspace.rootPath);

  switch (location) {
    case "root":
      return `# Auto-generated by tyvi init
# Marks this directory as a tyvi project root

export TYVI_ROOT="${rootPath}"
export TYVI_IN_PROJECT=1
`;

    case "lab":
      return `# Auto-generated by tyvi init
# Marks this directory as the tyvi lab (git allowed)

export TYVI_ROOT="${rootPath}"
export TYVI_IN_LAB=1
`;

    case "parent":
      return `# Auto-generated by tyvi init (optional parent guard)
# Re-sources tyvi shell integration for subshells

if [ -f "${rootPath}/shell/init.sh" ]; then
  source "${rootPath}/shell/init.sh"
fi
`;
  }
}

/**
 * Write .envrc file for a specific location.
 *
 * @param devspace - Devspace configuration
 * @param location - Where to write the .envrc
 * @returns Path to the written .envrc file
 */
export async function writeEnvrc(
  devspace: Devspace,
  location: "root" | "lab" | "parent",
): Promise<string> {
  const rootPath = resolve(devspace.rootPath);
  const labPath = resolve(
    rootPath,
    devspace.config.devspace.lab_path ?? ".lab",
  );

  let targetDir: string;
  switch (location) {
    case "root":
      targetDir = rootPath;
      break;
    case "lab":
      targetDir = labPath;
      break;
    case "parent":
      targetDir = resolve(rootPath, "..");
      break;
  }

  const envrcPath = join(targetDir, ".envrc");
  const content = generateEnvrc(devspace, location);

  await Deno.mkdir(targetDir, { recursive: true });
  await Deno.writeTextFile(envrcPath, content);

  return envrcPath;
}

/**
 * Run `direnv allow` for a directory.
 *
 * @param path - Directory containing the .envrc to allow
 */
export async function allowDirenv(path: string): Promise<void> {
  const envrcPath = join(path, ".envrc");
  if (!await exists(envrcPath)) {
    throw new Error(`No .envrc found at ${path}`);
  }

  const cmd = new Deno.Command("direnv", {
    args: ["allow", path],
    stdout: "null",
    stderr: "piped",
  });
  const result = await cmd.output();
  if (!result.success) {
    const stderr = new TextDecoder().decode(result.stderr);
    throw new Error(`direnv allow failed: ${stderr}`);
  }
}
